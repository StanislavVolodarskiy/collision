# Пересечение кругов

## Постановка

Задача возникла из вопроса [Эффективный алгоритм обработки коллизий *n*
кругов](https://ru.stackoverflow.com/questions/1614873) на
[ru.stackoverflow.com](https://ru.stackoverflow.com).

Дан набор из *n* кругов, требуется обнаружить все их попарные пересечения.
Простейшее решение за квадрат &ndash; измерить попарные расстояния между
центрами кругов. Если расстояние меньше суммы радиусов, пара включается в
ответ. *n* может достигать *10<sup>5</sup>*. В формулировке задачи упоминается
"каждый кадр", из чего можно сделать вывод, что речь о некоторой симуляции или
визуализации.

В отсутствие других ограничений простейшее решение может оказаться
оптимальным. В наборе из *n* шаров достаточно большого радиуса, центры которых
достаточно близки, каждый шар будет пересекать с каждым. А тогда длина списка
попарных пересечений станет порядка *n<sup>2</sup>*. То есть, для данной
конфигурации и данного формата ответа искать более быстрое решение бесполезно.

Надеюсь, что автор задачи имел ввиду другую ситуацию, которую я сейчас
додумаю за него. Пусть речь идёт о шарах которые двигаются в прямоугольнике,
упруго отталкиваются друг от друга и от стенок прямоугольника. Ситуация будет
симулироваться: за время *&Delta;t* все шары перемещаются по прямым. Затем
проверяются пересечения шаров, если они есть, имитируется их упругое
соударение. Если шары вышли за пределы прямоугольника, имитируется их упругий
отскок от стенок. Скорость движения шаров должна быть не слишком высока, так
чтобы за *&Delta;t* они не могли пролеть сквозь друг друга. После того как все
соударения обработаны, симуляция повторяется опять для следующего интервала
*&Delta;t*.

В такой постановке можно надеятся, что количество столконовений шаров каждый
кадр будет сравнительно не велико и появится смысл в ускорении поиска
столкновений шаров. Заодно можно будет сделать визуализацию движения шаров и
оценить насколько их движение естественно.

## Поиск пересечений шаров

Мне захотелось решить задачу сравнительно простыми средствами и измерить
эффективность этого решения.

Если все шары имеют близкие радиусы, то можно покрыть прямоугольник решёткой в
шагам немного больше двух радиусов шаров. Для каждого шара запишем с какими
клетками решётки он пересекается. Один шар запишется в максимум четыре клетки
и в каждой клетке окажется не более семи шаров (не уверен, но через площади
можно показать что шаров не более одиннадцати, а нас устроит любая константа).
Размещение шаров по клеткам требует линейного времени, обработка каждой не
пустой клетки делается за константу. То есть, все пересечения будут найдены за
линейное время.

К сожалению, если радиусы заметно различаются, то обе оценки перестают
работать: один большой шар может попасть в большое количество клеток, в одну
клетку может поместиться много маленьких шаров.

Построим [quadtree](https://en.wikipedia.org/wiki/Quadtree). Наложим на
прямоугольник квадрат, разбитый на четыре квадранта. Для каждого квадранта
составим список шаров, которые с ним пересекаются. Большинство шаров окажется
в одном квадранте, некоторый попадут в два, единицы окажутся в трёх или
четырёх. Процесс разбиения будем повторять рекурсивно, пока списки не станут
короче некоторого порога или пока глубина рекурсии не превысит установленного
предела. В каждом списке из листа дерева надо будет проделать попарную
проверку пересечения. Так как мы рассчитываем что списки не длинные, то и
проверка будет быстрой. Глубина дерева ограничена чтобы избежать ситуаций
когда много шаров попадают во много квадрантов и списки почти не укорачиваются
при разбиении.

В худшем случае этот алгоритм деградирует до квадратичного времени. В среднем
можно рассчитывать на *n&middot;<глубина дерева>&middot;<число шаров в
листе><sup>2</sup>*. В хорошей ситуации можно рассчитывать на почти линейную
сложность.

## Демо

Чтобы визуализацию можно было запустить в браузере, всё написано на
JavaScript. С другой стороны браузер не успевает отрисовать сто тысяч кругов
шестьдесят раз в секунду. Поэтому замеры для ста тысяч я буду считать в
node.js.

[Демонстрация](https://stanislavvolodarskiy.github.io/collision/) двигает
*8000* шаров радиусом от *80* до *2.5*. Шары упруго отталкиваются друг от
друга и от стенок. В заголовке минимальный/текущий/максимальный FPS и
статистика рассчёта столкновений.

![Кадр из демонстрации.](https://raw.githubusercontent.com/StanislavVolodarskiy/collision/refs/heads/main/article/demo.png)

Статистика требует дополнительных разъяснений.

`splits` &ndash; *50127* раз шары были пропущены через разбиения на квадранты.
Если это число разделить на число шаров получим среднюю глубину quadtree между
шестью и семью. В коде глубина дерева ограничена восемью.

`tests` &ndash; для *52590* пар шаров проверялось что они пересекаются. Без
quadtree число пар было бы около тридцати двух миллионов
(*<sup>8000&middot;7999</sup>/<sub>2</sub>*). Если предположить что деление на
квадранты проходило идеально (каждый шар попадал в один квадрант) и что все
группы в листьях дерева получились одинаковые, то тогда средний размер группы
около тринадцати. В коде группа ограничена двадцатью.

`collisions` &ndash; *1142* пары шаров пересеклись. Это число немного завышает
действительное число пересечений: при делении на квадранты одна пара может
попасть в два или больше квадрантов, тогда она попадёт в эту сумма несколько
раз. Но скорее всего эта сумма не намного завышает число пересечений.

`reactions` &ndash; *876* раз в паре шаров были изменены скорости.
Столкновение отрабатывается только если шары сближаются. Если они отдаляются,
менять скорости нет смысла. Благодаря этому пару шаров можно отправлять на
обработку столкновения несколько раз, а скорости будут изменены только один
раз.

Числа меняются от кадра к кадру но далеко от этих значений не уходят.

## *100000*

Демонстрация выше ограничениа *8000* шарами потому что для больших количеств
отрисовка тормозит и не укладывается в *60* FPS.
[benchmark.js](https://github.com/StanislavVolodarskiy/collision/blob/main/benchmark.js)
расчитывает столкновения без отрисовки. *&Delta;t* соответствует *60* FPS.

Запускать с помощью node.js:
```
$ node benchmark.js 1400 600 8000 80 2.5 50 2 8 20
box: 1400*600
balls: n 8000, radius 80 -> 2.5, v 50
collision: mode 2, max depth 8, leaf size 20
density: 0.35136073435531917
0 0.012115445017814636 49477 58554 6010 2283
1 0.005202482998371124 49472 58419 5432 663
2 0.0023678719997406008 49286 58658 4662 622
3 0.0012141909599304198 49309 58893 4022 574
4 0.0014024029970169068 49251 58319 3560 571
...
```

Скрипт печатает свои аргументы. Я рассказал про все кроме  
* `mode` &ndash; режим поиска пересечений. `0` &ndash; без пересечений,
`1` &ndash; проверка всех пар без оптимизаций, `2` &ndash; оптимизация
quadtree;
* `v` &ndash; скорость шаров на старте.

Параметр `density` показывает долю площади, которую шары занимают в
прямоугольнике.

Тест показывают что для *8000* шаров оптимизированный поиск столкновений
требует не более двух миллисекунд.

Аналогичный по плотности тест для *100000*:
```
$ node benchmark.js 3738 1602 100000 80 2.5 50 2 11 30
box: 3738*1602
balls: n 100000, radius 80 -> 2.5, v 50
collision: mode 2, max depth 11, leaf size 30
density: 0.3509455463760878
0 0.05418799197673797 735998 1322137 83318 35166
1 0.025981701970100402 736012 1318170 73605 15727
2 0.02525984400510788 735790 1316644 59694 14130
3 0.02153345203399658 735591 1320129 48575 14241
4 0.021713980972766875 735452 1318582 41063 14079
...
```

TODO: add analysis for stats on 100000
