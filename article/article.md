# Пересечение кругов

## Постановка

Задача возникла из вопроса [Эффективный алгоритм обработки коллизий *n*
кругов](https://ru.stackoverflow.com/questions/1614873) на
[ru.stackoverflow.com](https://ru.stackoverflow.com).

Дан набор из *n* кругов, требуется обнаружить все их попарные пересечения.
Простейшее решение за квадрат &ndash; измерить попарные расстояния между
центрами кругов. Если расстояние меньше суммы радиусов, пара включается в
ответ. *n* может достигать *10<sup>5</sup>*. В формулировке задачи упоминается
"каждый кадр", из чего можно сделать вывод, что речь о некоторой симуляции или
визуализации.

В отсутствие других ограничений простейшее решение может оказаться
оптимальным. В наборе из *n* шаров достаточно большого радиуса, центры которых
достаточно близки, каждый шар будет пересекать с каждым. А тогда длина списка
попарных пересечений станет порядка *n<sup>2</sup>*. То есть, для данной
конфигурации и данного формата ответа искать более быстрое решение бесполезно.

Надеюсь, что автор задачи имел ввиду другую ситуацию, которую я сейчас
додумаю за него. Пусть речь идёт о шарах которые двигаются в прямоугольнике,
упруго отталкиваются друг от друга и от стенок прямоугольника. Ситуация будет
симулироваться: за время *&delta;t* все шары перемещаются по прямым. Затем
проверяются пересечения шаров, если они есть, имитируется их упругое
соударение. Если шары вышли за пределы прямоугольника, имитируется их упругий
отскок от стенок. Скорость движения шаров должна быть не слишком высока, так
чтобы за *&delat;t* они не могли пролеть сквозь друг друга. После того как все
соударения обработаны, симуляция повторяется опять для следующего интервала
*&delta;t*.

В такой постановке можно надеятся, что количество столконовений шаров каждый
кадр будет сравнительно не велико и появится смысл в ускорении поиска
столкновений шаров. Заодно можно будет сделать визуализацию движения шаров и
оценить насколько их движение естественно.

## Поиск пересечений шаров

Мне захотелось решить задачу сравнительно простыми средствами и измерить
эффективность этого решения.

Если все шары имеют близкие радиусы, то можно покрыть прямоугольник решёткой в
шагам немного больше двух радиусов шаров. Для каждого шара запишем с какими
клетками решётки он пересекается. Один шар запишется в максимум четыре клетки
и в каждой клетке окажется не более семи шаров (не уверен, но через площади
можно показать что шаров не более одиннадцати, а нас устроит любая константа).
Размещение шаров по клеткам требует линейного времени, обработка каждой не
пустой клетки делается за константу. То есть, все пересечения будут найдены за
линейное время.

К сожалению, если радиусы заметно различаются, то обе оценки перестают
работать: один большой шар может попасть в большое количество клеток, в одну
клетку может поместиться много маленьких шаров.

Построим [quadtree](https://en.wikipedia.org/wiki/Quadtree). Наложим на
прямоугольник квадрат, разбитый на четыре квадранта. Для каждого квадранта
составим список шаров, которые с ним пересекаются. Большинство шаров окажется
в одном квадранте, некоторый попадут в два, единицы окажутся в трёх или
четырёх. Процесс разбиения будем повторять рекурсивно, пока списки не станут
короче некоторого порога или пока глубина рекурсии не превысит установленного
предела. В каждом списке из листа дерева надо будет проделать попарную
проверку пересечения. Так как мы рассчитываем что списки не длинные, то и
проверка будет быстрой. Глубина дерева ограничена чтобы избежать ситуаций
когда много шаров попадают во много квадрантов и списки почти не укорачиваются
при разбиении.

В худшем случае этот алгоритм деградирует до квадратичного времени. В среднем
можно рассчитывать на *n&middot;<глубина дерева>&middot;<число шаров в
листе><sup>2</sup>*. В хорошей ситуации можно рассчитывать на почти линейную
сложность.

## Демо

Чтобы визуализацию можно было запустить в браузере, всё написано на
JavaScript. С другой стороны браузер не успевает отрисовать сто тысяч кругов
шестьдесят раз в секунду. Поэтому замеры для ста тысяч я буду считать в
node.js.

[Демонстрация](https://stanislavvolodarskiy.github.io/collision/) двигает
*8000* шаров радиусом от *80* до *2.5*. Шары упруго отталкиваются друг от
друга и от стенок. В заголовке минимальный/текущий/максимальный FPS и
статистика рассчёта столкновений.

![Кадр из демонстрации.](https://raw.githubusercontent.com/StanislavVolodarskiy/collision/refs/heads/main/article/demo.png)

Статистика требует дополнительных разъяснений.

`splits` &ndash; *50127* раз шары были пропущены через разбиения на квадранты.
Если это число разделить на число шаров получим среднюю глубину quadtree между
шестью и семью. В коде глубина дерева ограничена восемью.

`tests` &ndash; для *52590* пар шаров проверялось что они пересекаются. Без
quadtree число пар было бы около тридцати двух миллионов
(*<sup>8000&middot;7999<sup>/<sub>2</sub>*). Если предположить что деление на
квадранты проходило идеально (каждый шар попадал в один квадрант) и что все
группы в листьях дерева получились одинаковые, то тогда средний размер группы
около тринадцати. В коде группа ограничена двадцатью.

`collisions' &ndash; *1142* пары шаров пересеклись. Это число немного завышает
действительное число пересечений: при делении на квадранты одна пара может
попасть в два или больше квадрантов, тогда она попадёт в эту сумма несколько
раз. Но скорее всего эта сумма не намного завышает число пересечение.

`reactions` &ndash; *876* раз в паре шаров были изменены скорости.
Столкновение отрабатывается только если шары сближаются. Если они отдаляются,
менять скорости нет смысла. Благодаря этому пару шаров можно отправлять на
обработку столкновения несколько раз, а скорости будут изменены только один
раз.
